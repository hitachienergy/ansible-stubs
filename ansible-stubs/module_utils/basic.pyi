from _typeshed import Incomplete
from ansible.module_utils.common.file import is_executable
from ansible.module_utils.pycompat24 import literal_eval
from ansible.module_utils.six import string_types, text_type

__metaclass__ = type
_PY3_MIN: Incomplete
_PY2_MIN: Incomplete
_PY_MIN: Incomplete
HAS_SYSLOG: bool
has_journal: Incomplete
HAVE_SELINUX: bool
NoneType: Incomplete

def _get_available_hash_algorithms(): ...

AVAILABLE_HASH_ALGORITHMS: Incomplete
SEQUENCETYPE: Incomplete
PASSWORD_MATCH: Incomplete
imap = map
unicode = text_type
basestring = string_types
_literal_eval = literal_eval
_ANSIBLE_ARGS: Incomplete
FILE_COMMON_ARGUMENTS: Incomplete
PASSWD_ARG_RE: Incomplete
MODE_OPERATOR_RE: Incomplete
USERS_RE: Incomplete
PERMS_RE: Incomplete

def get_platform(): ...
def load_platform_subclass(cls, *args, **kwargs): ...
def get_all_subclasses(cls): ...
def heuristic_log_sanitize(data, no_log_values: Incomplete | None = None): ...
def _load_params(): ...
def missing_required_lib(library, reason: Incomplete | None = None, url: Incomplete | None = None): ...

class AnsibleModule:
    _name: Incomplete
    argument_spec: Incomplete
    supports_check_mode: Incomplete
    check_mode: bool
    bypass_checks: Incomplete
    no_log: Incomplete
    mutually_exclusive: Incomplete
    required_together: Incomplete
    required_one_of: Incomplete
    required_if: Incomplete
    required_by: Incomplete
    cleanup_files: Incomplete
    _debug: bool
    _diff: bool
    _socket_path: Incomplete
    _shell: Incomplete
    _syslog_facility: str
    _verbosity: int
    run_command_environ_update: Incomplete
    _clean: Incomplete
    _string_conversion_action: str
    aliases: Incomplete
    _legal_inputs: Incomplete
    _options_context: Incomplete
    _tmpdir: Incomplete
    no_log_values: Incomplete
    validator: Incomplete
    validation_result: Incomplete
    _CHECK_ARGUMENT_TYPES_DISPATCHER: Incomplete
    _selinux_enabled: Incomplete
    _selinux_mls_enabled: Incomplete
    _selinux_initial_context: Incomplete
    def __init__(self, argument_spec, bypass_checks: bool = False, no_log: bool = False, mutually_exclusive: Incomplete | None = None, required_together: Incomplete | None = None, required_one_of: Incomplete | None = None, add_file_common_args: bool = False, supports_check_mode: bool = False, required_if: Incomplete | None = None, required_by: Incomplete | None = None) -> None: ...
    @property
    def tmpdir(self): ...
    def warn(self, warning) -> None: ...
    def deprecate(self, msg, version: Incomplete | None = None, date: Incomplete | None = None, collection_name: Incomplete | None = None) -> None: ...
    def load_file_common_arguments(self, params, path: Incomplete | None = None): ...
    def selinux_mls_enabled(self): ...
    def selinux_enabled(self): ...
    def selinux_initial_context(self): ...
    def selinux_default_context(self, path, mode: int = 0): ...
    def selinux_context(self, path): ...
    def user_and_group(self, path, expand: bool = True): ...
    def find_mount_point(self, path): ...
    def is_special_selinux_path(self, path): ...
    def set_default_selinux_context(self, path, changed): ...
    def set_context_if_different(self, path, context, changed, diff: Incomplete | None = None): ...
    def set_owner_if_different(self, path, owner, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def set_group_if_different(self, path, group, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def set_mode_if_different(self, path, mode, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def set_attributes_if_different(self, path, attributes, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def get_file_attributes(self, path, include_version: bool = True): ...
    @classmethod
    def _symbolic_mode_to_octal(cls, path_stat, symbolic_mode): ...
    @staticmethod
    def _apply_operation_to_mode(user, operator, mode_to_apply, current_mode): ...
    @staticmethod
    def _get_octal_mode_from_symbolic_perms(path_stat, user, perms, use_umask, prev_mode: Incomplete | None = None): ...
    def set_fs_attributes_if_different(self, file_args, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def check_file_absent_if_check_mode(self, file_path): ...
    def set_directory_attributes_if_different(self, file_args, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def set_file_attributes_if_different(self, file_args, changed, diff: Incomplete | None = None, expand: bool = True): ...
    def add_path_info(self, kwargs): ...
    def _check_locale(self) -> None: ...
    def _set_internal_properties(self, argument_spec: Incomplete | None = None, module_parameters: Incomplete | None = None) -> None: ...
    def safe_eval(self, value, locals: Incomplete | None = None, include_exceptions: bool = False): ...
    params: Incomplete
    def _load_params(self) -> None: ...
    def _log_to_syslog(self, msg) -> None: ...
    def debug(self, msg) -> None: ...
    def log(self, msg, log_args: Incomplete | None = None) -> None: ...
    def _log_invocation(self) -> None: ...
    def _set_cwd(self): ...
    def get_bin_path(self, arg, required: bool = False, opt_dirs: Incomplete | None = None): ...
    def boolean(self, arg): ...
    def jsonify(self, data): ...
    def from_json(self, data): ...
    def add_cleanup_file(self, path) -> None: ...
    def do_cleanup_files(self) -> None: ...
    def _return_formatted(self, kwargs) -> None: ...
    def exit_json(self, **kwargs) -> None: ...
    def fail_json(self, msg, **kwargs) -> None: ...
    def fail_on_missing_params(self, required_params: Incomplete | None = None) -> None: ...
    def digest_from_file(self, filename, algorithm): ...
    def md5(self, filename): ...
    def sha1(self, filename): ...
    def sha256(self, filename): ...
    def backup_local(self, fn): ...
    def cleanup(self, tmpfile) -> None: ...
    def preserved_copy(self, src, dest) -> None: ...
    def atomic_move(self, src, dest, unsafe_writes: bool = False) -> None: ...
    def _unsafe_writes(self, src, dest) -> None: ...
    def _clean_args(self, args): ...
    def _restore_signal_handlers(self) -> None: ...
    def run_command(self, args, check_rc: bool = False, close_fds: bool = True, executable: Incomplete | None = None, data: Incomplete | None = None, binary_data: bool = False, path_prefix: Incomplete | None = None, cwd: Incomplete | None = None, use_unsafe_shell: bool = False, prompt_regex: Incomplete | None = None, environ_update: Incomplete | None = None, umask: Incomplete | None = None, encoding: str = 'utf-8', errors: str = 'surrogate_or_strict', expand_user_and_vars: bool = True, pass_fds: Incomplete | None = None, before_communicate_callback: Incomplete | None = None, ignore_invalid_cwd: bool = True, handle_exceptions: bool = True): ...
    def append_to_file(self, filename, str) -> None: ...
    def bytes_to_human(self, size): ...
    pretty_bytes = bytes_to_human
    def human_to_bytes(self, number, isbits: bool = False): ...
    is_executable = is_executable
    @staticmethod
    def get_buffer_size(fd): ...

def get_module_path(): ...
